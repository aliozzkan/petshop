[{"/Volumes/Extreme SSD/myworkspace/petstore/src/index.tsx":"1","/Volumes/Extreme SSD/myworkspace/petstore/src/reportWebVitals.ts":"2","/Volumes/Extreme SSD/myworkspace/petstore/src/App.tsx":"3","/Volumes/Extreme SSD/myworkspace/petstore/src/store/index.ts":"4","/Volumes/Extreme SSD/myworkspace/petstore/src/store/app/reducer.ts":"5","/Volumes/Extreme SSD/myworkspace/petstore/src/store/app/constants.ts":"6","/Volumes/Extreme SSD/myworkspace/petstore/src/services/pet/index.ts":"7","/Volumes/Extreme SSD/myworkspace/petstore/src/services/pet/api.ts":"8","/Volumes/Extreme SSD/myworkspace/petstore/src/services/pet/configuration.ts":"9","/Volumes/Extreme SSD/myworkspace/petstore/src/services/index.ts":"10","/Volumes/Extreme SSD/myworkspace/petstore/src/hooks/fetch-manager.ts":"11","/Volumes/Extreme SSD/myworkspace/petstore/src/store/fetch/reducer.ts":"12","/Volumes/Extreme SSD/myworkspace/petstore/src/hooks/redux-hooks.tsx":"13","/Volumes/Extreme SSD/myworkspace/petstore/src/store/fetch/actions.ts":"14","/Volumes/Extreme SSD/myworkspace/petstore/src/components/templates/Slim.tsx":"15","/Volumes/Extreme SSD/myworkspace/petstore/src/components/organizms/Header.tsx":"16","/Volumes/Extreme SSD/myworkspace/petstore/src/components/pages/Home.tsx":"17","/Volumes/Extreme SSD/myworkspace/petstore/src/components/atoms/DarkModeSwitch/index.js":"18","/Volumes/Extreme SSD/myworkspace/petstore/src/components/organizms/Post.tsx":"19"},{"size":809,"mtime":1611161393949,"results":"20","hashOfConfig":"21"},{"size":425,"mtime":1611087580722,"results":"22","hashOfConfig":"21"},{"size":176,"mtime":1611168921175,"results":"23","hashOfConfig":"21"},{"size":752,"mtime":1611151591581,"results":"24","hashOfConfig":"21"},{"size":415,"mtime":1611089990169,"results":"25","hashOfConfig":"21"},{"size":91,"mtime":1611089234969,"results":"26","hashOfConfig":"21"},{"size":612,"mtime":1611090981018,"results":"27","hashOfConfig":"21"},{"size":82437,"mtime":1611090981014,"results":"28","hashOfConfig":"21"},{"size":1880,"mtime":1611090981015,"results":"29","hashOfConfig":"21"},{"size":564,"mtime":1611159431298,"results":"30","hashOfConfig":"21"},{"size":1586,"mtime":1611153421722,"results":"31","hashOfConfig":"21"},{"size":939,"mtime":1611151520324,"results":"32","hashOfConfig":"21"},{"size":310,"mtime":1611150459053,"results":"33","hashOfConfig":"21"},{"size":521,"mtime":1611150386350,"results":"34","hashOfConfig":"21"},{"size":403,"mtime":1611163018024,"results":"35","hashOfConfig":"21"},{"size":905,"mtime":1611167253444,"results":"36","hashOfConfig":"21"},{"size":299,"mtime":1611175403474,"results":"37","hashOfConfig":"21"},{"size":156,"mtime":1611162512791,"results":"38","hashOfConfig":"21"},{"size":1260,"mtime":1611176107157,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"1t4rt15",{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"42"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"42"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"42"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"62"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"42"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Volumes/Extreme SSD/myworkspace/petstore/src/index.tsx",[],["88","89"],"/Volumes/Extreme SSD/myworkspace/petstore/src/reportWebVitals.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/App.tsx",["90"],"import React, { ReactElement } from \"react\";\nimport FindPet from \"./components/pages/Home\";\n\nimport \"./App.css\";\n\nfunction App() {\n  return <FindPet />;\n}\n\nexport default App;\n","/Volumes/Extreme SSD/myworkspace/petstore/src/store/index.ts",["91"],"import { createStore, combineReducers, compose, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\n// import logger from \"redux-logger\";\nimport { appReducer } from \"./app/reducer\";\nimport { fetchReducer } from \"./fetch/reducer\";\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nconst allEnhancers = composeEnhancers(applyMiddleware(thunk));\n\nexport interface Store {\n  app: ReturnType<typeof appReducer>;\n  fetch: ReturnType<typeof fetchReducer>;\n}\n\nexport type store = Store;\nexport const store = createStore(\n  combineReducers({\n    app: appReducer,\n    fetch: fetchReducer\n  }),\n  allEnhancers\n);\n","/Volumes/Extreme SSD/myworkspace/petstore/src/store/app/reducer.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/store/app/constants.ts",["92"],"export const SET_APP_NAME = \"SET_APP_NAME\";\nexport type SET_APP_NAME = typeof SET_APP_NAME;","/Volumes/Extreme SSD/myworkspace/petstore/src/services/pet/index.ts",[],["93","94"],"/Volumes/Extreme SSD/myworkspace/petstore/src/services/pet/api.ts",["95","96","97","98","99","100","101","102","103","104","105","106","107"],"/// <reference path=\"./custom.d.ts\" />\n// tslint:disable\n/**\n * Swagger Petstore\n * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.\n *\n * OpenAPI spec version: 1.0.5\n * Contact: apiteam@swagger.io\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\nimport * as url from \"url\";\nimport * as portableFetch from \"portable-fetch\";\nimport { Configuration } from \"./configuration\";\n\nconst BASE_PATH = \"https://petstore.swagger.io/v2\".replace(/\\/+$/, \"\");\n\n/**\n *\n * @export\n */\nexport const COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n\n/**\n *\n * @export\n * @interface FetchAPI\n */\nexport interface FetchAPI {\n    (url: string, init?: any): Promise<Response>;\n}\n\n/**\n *\n * @export\n * @interface FetchArgs\n */\nexport interface FetchArgs {\n    url: string;\n    options: any;\n}\n\n/**\n *\n * @export\n * @class BaseAPI\n */\nexport class BaseAPI {\n    protected configuration: Configuration;\n\n    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath || this.basePath;\n        }\n    }\n};\n\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nexport class RequiredError extends Error {\n    name: \"RequiredError\"\n    constructor(public field: string, msg?: string) {\n        super(msg);\n    }\n}\n\n/**\n * \n * @export\n * @interface ApiResponse\n */\nexport interface ApiResponse {\n    /**\n     * \n     * @type {number}\n     * @memberof ApiResponse\n     */\n    code?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof ApiResponse\n     */\n    type?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof ApiResponse\n     */\n    message?: string;\n}\n\n/**\n * \n * @export\n * @interface Category\n */\nexport interface Category {\n    /**\n     * \n     * @type {number}\n     * @memberof Category\n     */\n    id?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof Category\n     */\n    name?: string;\n}\n\n/**\n * \n * @export\n * @interface Order\n */\nexport interface Order {\n    /**\n     * \n     * @type {number}\n     * @memberof Order\n     */\n    id?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Order\n     */\n    petId?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Order\n     */\n    quantity?: number;\n    /**\n     * \n     * @type {Date}\n     * @memberof Order\n     */\n    shipDate?: Date;\n    /**\n     * Order Status\n     * @type {string}\n     * @memberof Order\n     */\n    status?: Order.StatusEnum;\n    /**\n     * \n     * @type {boolean}\n     * @memberof Order\n     */\n    complete?: boolean;\n}\n\n/**\n * @export\n * @namespace Order\n */\nexport namespace Order {\n    /**\n     * @export\n     * @enum {string}\n     */\n    export enum StatusEnum {\n        Placed = <any> 'placed',\n        Approved = <any> 'approved',\n        Delivered = <any> 'delivered'\n    }\n}\n\n/**\n * \n * @export\n * @interface Pet\n */\nexport interface Pet {\n    /**\n     * \n     * @type {number}\n     * @memberof Pet\n     */\n    id?: number;\n    /**\n     * \n     * @type {Category}\n     * @memberof Pet\n     */\n    category?: Category;\n    /**\n     * \n     * @type {string}\n     * @memberof Pet\n     */\n    name: string;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof Pet\n     */\n    photoUrls: Array<string>;\n    /**\n     * \n     * @type {Array<Tag>}\n     * @memberof Pet\n     */\n    tags?: Array<Tag>;\n    /**\n     * pet status in the store\n     * @type {string}\n     * @memberof Pet\n     */\n    status?: Pet.StatusEnum;\n}\n\n/**\n * @export\n * @namespace Pet\n */\nexport namespace Pet {\n    /**\n     * @export\n     * @enum {string}\n     */\n    export enum StatusEnum {\n        Available = <any> 'available',\n        Pending = <any> 'pending',\n        Sold = <any> 'sold'\n    }\n}\n\n/**\n * \n * @export\n * @interface Tag\n */\nexport interface Tag {\n    /**\n     * \n     * @type {number}\n     * @memberof Tag\n     */\n    id?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof Tag\n     */\n    name?: string;\n}\n\n/**\n * \n * @export\n * @interface User\n */\nexport interface User {\n    /**\n     * \n     * @type {number}\n     * @memberof User\n     */\n    id?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    username?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    firstName?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    lastName?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    email?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    password?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    phone?: string;\n    /**\n     * User Status\n     * @type {number}\n     * @memberof User\n     */\n    userStatus?: number;\n}\n\n\n/**\n * PetApi - fetch parameter creator\n * @export\n */\nexport const PetApiFetchParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Add a new pet to the store\n         * @param {Pet} body Pet object that needs to be added to the store\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addPet(body: Pet, options: any = {}): FetchArgs {\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling addPet.');\n            }\n            const localVarPath = `/pet`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"Pet\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Deletes a pet\n         * @param {number} petId Pet id to delete\n         * @param {string} [apiKey] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deletePet(petId: number, apiKey?: string, options: any = {}): FetchArgs {\n            // verify required parameter 'petId' is not null or undefined\n            if (petId === null || petId === undefined) {\n                throw new RequiredError('petId','Required parameter petId was null or undefined when calling deletePet.');\n            }\n            const localVarPath = `/pet/{petId}`\n                .replace(`{${\"petId\"}}`, encodeURIComponent(String(petId)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            if (apiKey !== undefined && apiKey !== null) {\n                localVarHeaderParameter['api_key'] = String(apiKey);\n            }\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Multiple status values can be provided with comma separated strings\n         * @summary Finds Pets by status\n         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options: any = {}): FetchArgs {\n            // verify required parameter 'status' is not null or undefined\n            if (status === null || status === undefined) {\n                throw new RequiredError('status','Required parameter status was null or undefined when calling findPetsByStatus.');\n            }\n            const localVarPath = `/pet/findByStatus`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            if (status) {\n                localVarQueryParameter['status'] = status;\n            }\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n         * @summary Finds Pets by tags\n         * @param {Array<string>} tags Tags to filter by\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        findPetsByTags(tags: Array<string>, options: any = {}): FetchArgs {\n            // verify required parameter 'tags' is not null or undefined\n            if (tags === null || tags === undefined) {\n                throw new RequiredError('tags','Required parameter tags was null or undefined when calling findPetsByTags.');\n            }\n            const localVarPath = `/pet/findByTags`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            if (tags) {\n                localVarQueryParameter['tags'] = tags;\n            }\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a single pet\n         * @summary Find pet by ID\n         * @param {number} petId ID of pet to return\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPetById(petId: number, options: any = {}): FetchArgs {\n            // verify required parameter 'petId' is not null or undefined\n            if (petId === null || petId === undefined) {\n                throw new RequiredError('petId','Required parameter petId was null or undefined when calling getPetById.');\n            }\n            const localVarPath = `/pet/{petId}`\n                .replace(`{${\"petId\"}}`, encodeURIComponent(String(petId)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication api_key required\n            if (configuration && configuration.apiKey) {\n                const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n\t\t\t\t\t? configuration.apiKey(\"api_key\")\n\t\t\t\t\t: configuration.apiKey;\n                localVarHeaderParameter[\"api_key\"] = localVarApiKeyValue;\n            }\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update an existing pet\n         * @param {Pet} body Pet object that needs to be added to the store\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePet(body: Pet, options: any = {}): FetchArgs {\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePet.');\n            }\n            const localVarPath = `/pet`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"Pet\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Updates a pet in the store with form data\n         * @param {number} petId ID of pet that needs to be updated\n         * @param {string} [name] Updated name of the pet\n         * @param {string} [status] Updated status of the pet\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePetWithForm(petId: number, name?: string, status?: string, options: any = {}): FetchArgs {\n            // verify required parameter 'petId' is not null or undefined\n            if (petId === null || petId === undefined) {\n                throw new RequiredError('petId','Required parameter petId was null or undefined when calling updatePetWithForm.');\n            }\n            const localVarPath = `/pet/{petId}`\n                .replace(`{${\"petId\"}}`, encodeURIComponent(String(petId)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new url.URLSearchParams();\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            if (name !== undefined) {\n                localVarFormParams.set('name', name as any);\n            }\n\n            if (status !== undefined) {\n                localVarFormParams.set('status', status as any);\n            }\n\n            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            localVarRequestOptions.body = localVarFormParams.toString();\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary uploads an image\n         * @param {number} petId ID of pet to update\n         * @param {string} [additionalMetadata] Additional data to pass to server\n         * @param {any} [file] file to upload\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        uploadFile(petId: number, additionalMetadata?: string, file?: any, options: any = {}): FetchArgs {\n            // verify required parameter 'petId' is not null or undefined\n            if (petId === null || petId === undefined) {\n                throw new RequiredError('petId','Required parameter petId was null or undefined when calling uploadFile.');\n            }\n            const localVarPath = `/pet/{petId}/uploadImage`\n                .replace(`{${\"petId\"}}`, encodeURIComponent(String(petId)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new url.URLSearchParams();\n\n            // authentication petstore_auth required\n            // oauth required\n            if (configuration && configuration.accessToken) {\n\t\t\t\tconst localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n\t\t\t\t\t? configuration.accessToken(\"petstore_auth\", [\"write:pets\", \"read:pets\"])\n\t\t\t\t\t: configuration.accessToken;\n                localVarHeaderParameter[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n            }\n\n            if (additionalMetadata !== undefined) {\n                localVarFormParams.set('additionalMetadata', additionalMetadata as any);\n            }\n\n            if (file !== undefined) {\n                localVarFormParams.set('file', file as any);\n            }\n\n            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            localVarRequestOptions.body = localVarFormParams.toString();\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * PetApi - functional programming interface\n * @export\n */\nexport const PetApiFp = function(configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Add a new pet to the store\n         * @param {Pet} body Pet object that needs to be added to the store\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addPet(body: Pet, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).addPet(body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Deletes a pet\n         * @param {number} petId Pet id to delete\n         * @param {string} [apiKey] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deletePet(petId: number, apiKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).deletePet(petId, apiKey, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * Multiple status values can be provided with comma separated strings\n         * @summary Finds Pets by status\n         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pet>> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).findPetsByStatus(status, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n         * @summary Finds Pets by tags\n         * @param {Array<string>} tags Tags to filter by\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        findPetsByTags(tags: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pet>> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).findPetsByTags(tags, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * Returns a single pet\n         * @summary Find pet by ID\n         * @param {number} petId ID of pet to return\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPetById(petId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pet> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).getPetById(petId, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Update an existing pet\n         * @param {Pet} body Pet object that needs to be added to the store\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePet(body: Pet, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).updatePet(body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Updates a pet in the store with form data\n         * @param {number} petId ID of pet that needs to be updated\n         * @param {string} [name] Updated name of the pet\n         * @param {string} [status] Updated status of the pet\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePetWithForm(petId: number, name?: string, status?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).updatePetWithForm(petId, name, status, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary uploads an image\n         * @param {number} petId ID of pet to update\n         * @param {string} [additionalMetadata] Additional data to pass to server\n         * @param {any} [file] file to upload\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {\n            const localVarFetchArgs = PetApiFetchParamCreator(configuration).uploadFile(petId, additionalMetadata, file, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n    }\n};\n\n/**\n * PetApi - factory interface\n * @export\n */\nexport const PetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         * \n         * @summary Add a new pet to the store\n         * @param {Pet} body Pet object that needs to be added to the store\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addPet(body: Pet, options?: any) {\n            return PetApiFp(configuration).addPet(body, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Deletes a pet\n         * @param {number} petId Pet id to delete\n         * @param {string} [apiKey] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deletePet(petId: number, apiKey?: string, options?: any) {\n            return PetApiFp(configuration).deletePet(petId, apiKey, options)(fetch, basePath);\n        },\n        /**\n         * Multiple status values can be provided with comma separated strings\n         * @summary Finds Pets by status\n         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any) {\n            return PetApiFp(configuration).findPetsByStatus(status, options)(fetch, basePath);\n        },\n        /**\n         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n         * @summary Finds Pets by tags\n         * @param {Array<string>} tags Tags to filter by\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        findPetsByTags(tags: Array<string>, options?: any) {\n            return PetApiFp(configuration).findPetsByTags(tags, options)(fetch, basePath);\n        },\n        /**\n         * Returns a single pet\n         * @summary Find pet by ID\n         * @param {number} petId ID of pet to return\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPetById(petId: number, options?: any) {\n            return PetApiFp(configuration).getPetById(petId, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Update an existing pet\n         * @param {Pet} body Pet object that needs to be added to the store\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePet(body: Pet, options?: any) {\n            return PetApiFp(configuration).updatePet(body, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Updates a pet in the store with form data\n         * @param {number} petId ID of pet that needs to be updated\n         * @param {string} [name] Updated name of the pet\n         * @param {string} [status] Updated status of the pet\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePetWithForm(petId: number, name?: string, status?: string, options?: any) {\n            return PetApiFp(configuration).updatePetWithForm(petId, name, status, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary uploads an image\n         * @param {number} petId ID of pet to update\n         * @param {string} [additionalMetadata] Additional data to pass to server\n         * @param {any} [file] file to upload\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any) {\n            return PetApiFp(configuration).uploadFile(petId, additionalMetadata, file, options)(fetch, basePath);\n        },\n    };\n};\n\n/**\n * PetApi - object-oriented interface\n * @export\n * @class PetApi\n * @extends {BaseAPI}\n */\nexport class PetApi extends BaseAPI {\n    /**\n     * \n     * @summary Add a new pet to the store\n     * @param {Pet} body Pet object that needs to be added to the store\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public addPet(body: Pet, options?: any) {\n        return PetApiFp(this.configuration).addPet(body, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Deletes a pet\n     * @param {number} petId Pet id to delete\n     * @param {string} [apiKey] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public deletePet(petId: number, apiKey?: string, options?: any) {\n        return PetApiFp(this.configuration).deletePet(petId, apiKey, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * Multiple status values can be provided with comma separated strings\n     * @summary Finds Pets by status\n     * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any) {\n        return PetApiFp(this.configuration).findPetsByStatus(status, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n     * @summary Finds Pets by tags\n     * @param {Array<string>} tags Tags to filter by\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public findPetsByTags(tags: Array<string>, options?: any) {\n        return PetApiFp(this.configuration).findPetsByTags(tags, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * Returns a single pet\n     * @summary Find pet by ID\n     * @param {number} petId ID of pet to return\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public getPetById(petId: number, options?: any) {\n        return PetApiFp(this.configuration).getPetById(petId, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Update an existing pet\n     * @param {Pet} body Pet object that needs to be added to the store\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public updatePet(body: Pet, options?: any) {\n        return PetApiFp(this.configuration).updatePet(body, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Updates a pet in the store with form data\n     * @param {number} petId ID of pet that needs to be updated\n     * @param {string} [name] Updated name of the pet\n     * @param {string} [status] Updated status of the pet\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public updatePetWithForm(petId: number, name?: string, status?: string, options?: any) {\n        return PetApiFp(this.configuration).updatePetWithForm(petId, name, status, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary uploads an image\n     * @param {number} petId ID of pet to update\n     * @param {string} [additionalMetadata] Additional data to pass to server\n     * @param {any} [file] file to upload\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PetApi\n     */\n    public uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any) {\n        return PetApiFp(this.configuration).uploadFile(petId, additionalMetadata, file, options)(this.fetch, this.basePath);\n    }\n\n}\n\n/**\n * StoreApi - fetch parameter creator\n * @export\n */\nexport const StoreApiFetchParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors\n         * @summary Delete purchase order by ID\n         * @param {number} orderId ID of the order that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteOrder(orderId: number, options: any = {}): FetchArgs {\n            // verify required parameter 'orderId' is not null or undefined\n            if (orderId === null || orderId === undefined) {\n                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling deleteOrder.');\n            }\n            const localVarPath = `/store/order/{orderId}`\n                .replace(`{${\"orderId\"}}`, encodeURIComponent(String(orderId)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a map of status codes to quantities\n         * @summary Returns pet inventories by status\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getInventory(options: any = {}): FetchArgs {\n            const localVarPath = `/store/inventory`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication api_key required\n            if (configuration && configuration.apiKey) {\n                const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n\t\t\t\t\t? configuration.apiKey(\"api_key\")\n\t\t\t\t\t: configuration.apiKey;\n                localVarHeaderParameter[\"api_key\"] = localVarApiKeyValue;\n            }\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions\n         * @summary Find purchase order by ID\n         * @param {number} orderId ID of pet that needs to be fetched\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrderById(orderId: number, options: any = {}): FetchArgs {\n            // verify required parameter 'orderId' is not null or undefined\n            if (orderId === null || orderId === undefined) {\n                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderById.');\n            }\n            const localVarPath = `/store/order/{orderId}`\n                .replace(`{${\"orderId\"}}`, encodeURIComponent(String(orderId)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Place an order for a pet\n         * @param {Order} body order placed for purchasing the pet\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        placeOrder(body: Order, options: any = {}): FetchArgs {\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling placeOrder.');\n            }\n            const localVarPath = `/store/order`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"Order\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * StoreApi - functional programming interface\n * @export\n */\nexport const StoreApiFp = function(configuration?: Configuration) {\n    return {\n        /**\n         * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors\n         * @summary Delete purchase order by ID\n         * @param {number} orderId ID of the order that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteOrder(orderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = StoreApiFetchParamCreator(configuration).deleteOrder(orderId, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * Returns a map of status codes to quantities\n         * @summary Returns pet inventories by status\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getInventory(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {\n            const localVarFetchArgs = StoreApiFetchParamCreator(configuration).getInventory(options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions\n         * @summary Find purchase order by ID\n         * @param {number} orderId ID of pet that needs to be fetched\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrderById(orderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {\n            const localVarFetchArgs = StoreApiFetchParamCreator(configuration).getOrderById(orderId, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Place an order for a pet\n         * @param {Order} body order placed for purchasing the pet\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        placeOrder(body: Order, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {\n            const localVarFetchArgs = StoreApiFetchParamCreator(configuration).placeOrder(body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n    }\n};\n\n/**\n * StoreApi - factory interface\n * @export\n */\nexport const StoreApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors\n         * @summary Delete purchase order by ID\n         * @param {number} orderId ID of the order that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteOrder(orderId: number, options?: any) {\n            return StoreApiFp(configuration).deleteOrder(orderId, options)(fetch, basePath);\n        },\n        /**\n         * Returns a map of status codes to quantities\n         * @summary Returns pet inventories by status\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getInventory(options?: any) {\n            return StoreApiFp(configuration).getInventory(options)(fetch, basePath);\n        },\n        /**\n         * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions\n         * @summary Find purchase order by ID\n         * @param {number} orderId ID of pet that needs to be fetched\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrderById(orderId: number, options?: any) {\n            return StoreApiFp(configuration).getOrderById(orderId, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Place an order for a pet\n         * @param {Order} body order placed for purchasing the pet\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        placeOrder(body: Order, options?: any) {\n            return StoreApiFp(configuration).placeOrder(body, options)(fetch, basePath);\n        },\n    };\n};\n\n/**\n * StoreApi - object-oriented interface\n * @export\n * @class StoreApi\n * @extends {BaseAPI}\n */\nexport class StoreApi extends BaseAPI {\n    /**\n     * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors\n     * @summary Delete purchase order by ID\n     * @param {number} orderId ID of the order that needs to be deleted\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StoreApi\n     */\n    public deleteOrder(orderId: number, options?: any) {\n        return StoreApiFp(this.configuration).deleteOrder(orderId, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * Returns a map of status codes to quantities\n     * @summary Returns pet inventories by status\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StoreApi\n     */\n    public getInventory(options?: any) {\n        return StoreApiFp(this.configuration).getInventory(options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions\n     * @summary Find purchase order by ID\n     * @param {number} orderId ID of pet that needs to be fetched\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StoreApi\n     */\n    public getOrderById(orderId: number, options?: any) {\n        return StoreApiFp(this.configuration).getOrderById(orderId, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Place an order for a pet\n     * @param {Order} body order placed for purchasing the pet\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StoreApi\n     */\n    public placeOrder(body: Order, options?: any) {\n        return StoreApiFp(this.configuration).placeOrder(body, options)(this.fetch, this.basePath);\n    }\n\n}\n\n/**\n * UserApi - fetch parameter creator\n * @export\n */\nexport const UserApiFetchParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * This can only be done by the logged in user.\n         * @summary Create user\n         * @param {User} body Created user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUser(body: User, options: any = {}): FetchArgs {\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');\n            }\n            const localVarPath = `/user`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"User\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Creates list of users with given input array\n         * @param {Array<User>} body List of user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsersWithArrayInput(body: Array<User>, options: any = {}): FetchArgs {\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling createUsersWithArrayInput.');\n            }\n            const localVarPath = `/user/createWithArray`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"Array&lt;User&gt;\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Creates list of users with given input array\n         * @param {Array<User>} body List of user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsersWithListInput(body: Array<User>, options: any = {}): FetchArgs {\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling createUsersWithListInput.');\n            }\n            const localVarPath = `/user/createWithList`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"Array&lt;User&gt;\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This can only be done by the logged in user.\n         * @summary Delete user\n         * @param {string} username The name that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUser(username: string, options: any = {}): FetchArgs {\n            // verify required parameter 'username' is not null or undefined\n            if (username === null || username === undefined) {\n                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUser.');\n            }\n            const localVarPath = `/user/{username}`\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get user by user name\n         * @param {string} username The name that needs to be fetched. Use user1 for testing. \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserByName(username: string, options: any = {}): FetchArgs {\n            // verify required parameter 'username' is not null or undefined\n            if (username === null || username === undefined) {\n                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserByName.');\n            }\n            const localVarPath = `/user/{username}`\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Logs user into the system\n         * @param {string} username The user name for login\n         * @param {string} password The password for login in clear text\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        loginUser(username: string, password: string, options: any = {}): FetchArgs {\n            // verify required parameter 'username' is not null or undefined\n            if (username === null || username === undefined) {\n                throw new RequiredError('username','Required parameter username was null or undefined when calling loginUser.');\n            }\n            // verify required parameter 'password' is not null or undefined\n            if (password === null || password === undefined) {\n                throw new RequiredError('password','Required parameter password was null or undefined when calling loginUser.');\n            }\n            const localVarPath = `/user/login`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (username !== undefined) {\n                localVarQueryParameter['username'] = username;\n            }\n\n            if (password !== undefined) {\n                localVarQueryParameter['password'] = password;\n            }\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Logs out current logged in user session\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        logoutUser(options: any = {}): FetchArgs {\n            const localVarPath = `/user/logout`;\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This can only be done by the logged in user.\n         * @summary Updated user\n         * @param {string} username name that need to be updated\n         * @param {User} body Updated user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUser(username: string, body: User, options: any = {}): FetchArgs {\n            // verify required parameter 'username' is not null or undefined\n            if (username === null || username === undefined) {\n                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUser.');\n            }\n            // verify required parameter 'body' is not null or undefined\n            if (body === null || body === undefined) {\n                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');\n            }\n            const localVarPath = `/user/{username}`\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            const localVarUrlObj = url.parse(localVarPath, true);\n            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);\n            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943\n            delete localVarUrlObj.search;\n            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);\n            const needsSerialization = (<any>\"User\" !== \"string\") || localVarRequestOptions.headers['Content-Type'] === 'application/json';\n            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || \"\");\n\n            return {\n                url: url.format(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * UserApi - functional programming interface\n * @export\n */\nexport const UserApiFp = function(configuration?: Configuration) {\n    return {\n        /**\n         * This can only be done by the logged in user.\n         * @summary Create user\n         * @param {User} body Created user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUser(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUser(body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Creates list of users with given input array\n         * @param {Array<User>} body List of user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsersWithArrayInput(body: Array<User>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUsersWithArrayInput(body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Creates list of users with given input array\n         * @param {Array<User>} body List of user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsersWithListInput(body: Array<User>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUsersWithListInput(body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * This can only be done by the logged in user.\n         * @summary Delete user\n         * @param {string} username The name that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUser(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(username, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Get user by user name\n         * @param {string} username The name that needs to be fetched. Use user1 for testing. \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserByName(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserByName(username, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Logs user into the system\n         * @param {string} username The user name for login\n         * @param {string} password The password for login in clear text\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        loginUser(username: string, password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).loginUser(username, password, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response.json();\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * \n         * @summary Logs out current logged in user session\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        logoutUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).logoutUser(options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n        /**\n         * This can only be done by the logged in user.\n         * @summary Updated user\n         * @param {string} username name that need to be updated\n         * @param {User} body Updated user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUser(username: string, body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {\n            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(username, body, options);\n            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {\n                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {\n                    if (response.status >= 200 && response.status < 300) {\n                        return response;\n                    } else {\n                        throw response;\n                    }\n                });\n            };\n        },\n    }\n};\n\n/**\n * UserApi - factory interface\n * @export\n */\nexport const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         * This can only be done by the logged in user.\n         * @summary Create user\n         * @param {User} body Created user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUser(body: User, options?: any) {\n            return UserApiFp(configuration).createUser(body, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Creates list of users with given input array\n         * @param {Array<User>} body List of user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsersWithArrayInput(body: Array<User>, options?: any) {\n            return UserApiFp(configuration).createUsersWithArrayInput(body, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Creates list of users with given input array\n         * @param {Array<User>} body List of user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsersWithListInput(body: Array<User>, options?: any) {\n            return UserApiFp(configuration).createUsersWithListInput(body, options)(fetch, basePath);\n        },\n        /**\n         * This can only be done by the logged in user.\n         * @summary Delete user\n         * @param {string} username The name that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUser(username: string, options?: any) {\n            return UserApiFp(configuration).deleteUser(username, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Get user by user name\n         * @param {string} username The name that needs to be fetched. Use user1 for testing. \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserByName(username: string, options?: any) {\n            return UserApiFp(configuration).getUserByName(username, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Logs user into the system\n         * @param {string} username The user name for login\n         * @param {string} password The password for login in clear text\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        loginUser(username: string, password: string, options?: any) {\n            return UserApiFp(configuration).loginUser(username, password, options)(fetch, basePath);\n        },\n        /**\n         * \n         * @summary Logs out current logged in user session\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        logoutUser(options?: any) {\n            return UserApiFp(configuration).logoutUser(options)(fetch, basePath);\n        },\n        /**\n         * This can only be done by the logged in user.\n         * @summary Updated user\n         * @param {string} username name that need to be updated\n         * @param {User} body Updated user object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUser(username: string, body: User, options?: any) {\n            return UserApiFp(configuration).updateUser(username, body, options)(fetch, basePath);\n        },\n    };\n};\n\n/**\n * UserApi - object-oriented interface\n * @export\n * @class UserApi\n * @extends {BaseAPI}\n */\nexport class UserApi extends BaseAPI {\n    /**\n     * This can only be done by the logged in user.\n     * @summary Create user\n     * @param {User} body Created user object\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public createUser(body: User, options?: any) {\n        return UserApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Creates list of users with given input array\n     * @param {Array<User>} body List of user object\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public createUsersWithArrayInput(body: Array<User>, options?: any) {\n        return UserApiFp(this.configuration).createUsersWithArrayInput(body, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Creates list of users with given input array\n     * @param {Array<User>} body List of user object\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public createUsersWithListInput(body: Array<User>, options?: any) {\n        return UserApiFp(this.configuration).createUsersWithListInput(body, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * This can only be done by the logged in user.\n     * @summary Delete user\n     * @param {string} username The name that needs to be deleted\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public deleteUser(username: string, options?: any) {\n        return UserApiFp(this.configuration).deleteUser(username, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Get user by user name\n     * @param {string} username The name that needs to be fetched. Use user1 for testing. \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public getUserByName(username: string, options?: any) {\n        return UserApiFp(this.configuration).getUserByName(username, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Logs user into the system\n     * @param {string} username The user name for login\n     * @param {string} password The password for login in clear text\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public loginUser(username: string, password: string, options?: any) {\n        return UserApiFp(this.configuration).loginUser(username, password, options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * \n     * @summary Logs out current logged in user session\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public logoutUser(options?: any) {\n        return UserApiFp(this.configuration).logoutUser(options)(this.fetch, this.basePath);\n    }\n\n    /**\n     * This can only be done by the logged in user.\n     * @summary Updated user\n     * @param {string} username name that need to be updated\n     * @param {User} body Updated user object\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    public updateUser(username: string, body: User, options?: any) {\n        return UserApiFp(this.configuration).updateUser(username, body, options)(this.fetch, this.basePath);\n    }\n\n}\n\n",["108","109"],"/Volumes/Extreme SSD/myworkspace/petstore/src/services/pet/configuration.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/services/index.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/hooks/fetch-manager.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/store/fetch/reducer.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/hooks/redux-hooks.tsx",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/store/fetch/actions.ts",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/components/templates/Slim.tsx",["110","111","112"],"import React, { PropsWithChildren } from \"react\";\nimport { Box, Container, Flex, useColorMode } from \"@chakra-ui/react\";\nimport HeaderOrg from \"../organizms/Header\";\nimport DarkModeSwitch from \"../atoms/DarkModeSwitch\";\n\nfunction Slim({ children }: PropsWithChildren<{}>) {\n  return (\n    <Box>\n      <HeaderOrg />\n      <Container mt=\"10\">{children}</Container>\n    </Box>\n  );\n}\n\nexport default Slim;\n","/Volumes/Extreme SSD/myworkspace/petstore/src/components/organizms/Header.tsx",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/components/pages/Home.tsx",[],"/Volumes/Extreme SSD/myworkspace/petstore/src/components/atoms/DarkModeSwitch/index.js",["113"],"import React from 'react'\nimport DarkModeToggle from \"react-dark-mode-toggle\";\n\nexport default function (props) {\n  return <DarkModeToggle {...props} />;\n}\n",["114","115"],"/Volumes/Extreme SSD/myworkspace/petstore/src/components/organizms/Post.tsx",[],{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","replacedBy":"119"},{"ruleId":"120","severity":1,"message":"121","line":1,"column":17,"nodeType":"122","messageId":"123","endLine":1,"endColumn":29},{"ruleId":"124","severity":1,"message":"125","line":23,"column":14,"nodeType":"122","messageId":"126","endLine":23,"endColumn":19},{"ruleId":"124","severity":1,"message":"127","line":2,"column":13,"nodeType":"122","messageId":"126","endLine":2,"endColumn":25},{"ruleId":"116","replacedBy":"128"},{"ruleId":"118","replacedBy":"129"},{"ruleId":"130","severity":1,"message":"131","line":181,"column":18,"nodeType":"132","messageId":"133","endLine":181,"endColumn":32},{"ruleId":"130","severity":1,"message":"131","line":182,"column":20,"nodeType":"132","messageId":"133","endLine":182,"endColumn":36},{"ruleId":"130","severity":1,"message":"131","line":183,"column":21,"nodeType":"132","messageId":"133","endLine":183,"endColumn":38},{"ruleId":"130","severity":1,"message":"131","line":241,"column":21,"nodeType":"132","messageId":"133","endLine":241,"endColumn":38},{"ruleId":"130","severity":1,"message":"131","line":242,"column":19,"nodeType":"132","messageId":"133","endLine":242,"endColumn":34},{"ruleId":"130","severity":1,"message":"131","line":243,"column":16,"nodeType":"132","messageId":"133","endLine":243,"endColumn":28},{"ruleId":"130","severity":1,"message":"131","line":363,"column":41,"nodeType":"132","messageId":"133","endLine":363,"endColumn":51},{"ruleId":"130","severity":1,"message":"131","line":566,"column":41,"nodeType":"132","messageId":"133","endLine":566,"endColumn":51},{"ruleId":"130","severity":1,"message":"131","line":1170,"column":41,"nodeType":"132","messageId":"133","endLine":1170,"endColumn":53},{"ruleId":"130","severity":1,"message":"131","line":1399,"column":41,"nodeType":"132","messageId":"133","endLine":1399,"endColumn":52},{"ruleId":"130","severity":1,"message":"131","line":1431,"column":41,"nodeType":"132","messageId":"133","endLine":1431,"endColumn":65},{"ruleId":"130","severity":1,"message":"131","line":1463,"column":41,"nodeType":"132","messageId":"133","endLine":1463,"endColumn":65},{"ruleId":"130","severity":1,"message":"131","line":1623,"column":41,"nodeType":"132","messageId":"133","endLine":1623,"endColumn":52},{"ruleId":"116","replacedBy":"134"},{"ruleId":"118","replacedBy":"135"},{"ruleId":"120","severity":1,"message":"136","line":2,"column":26,"nodeType":"122","messageId":"123","endLine":2,"endColumn":30},{"ruleId":"120","severity":1,"message":"137","line":2,"column":32,"nodeType":"122","messageId":"123","endLine":2,"endColumn":44},{"ruleId":"120","severity":1,"message":"138","line":4,"column":8,"nodeType":"122","messageId":"123","endLine":4,"endColumn":22},{"ruleId":"139","severity":1,"message":"140","line":4,"column":1,"nodeType":"141","endLine":6,"endColumn":2},{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","replacedBy":"119"},"no-native-reassign",["142"],"no-negated-in-lhs",["143"],"@typescript-eslint/no-unused-vars","'ReactElement' is defined but never used.","Identifier","unusedVar","@typescript-eslint/no-redeclare","'store' is already defined.","redeclared","'SET_APP_NAME' is already defined.",["142"],["143"],"@typescript-eslint/consistent-type-assertions","Use 'as any' instead of '<any>'.","TSTypeAssertion","as",["142"],["143"],"'Flex' is defined but never used.","'useColorMode' is defined but never used.","'DarkModeSwitch' is defined but never used.","import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]